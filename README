This is an initial draft of the libzcloud interfaces, which aim to provide an
abstraction for the various cloud storage services.

The core of libzcloud's abstraction is the "store". The methods that the
store must support are:
* create
* upload
* download
* delete
* exists
* list
* parse_address
* parse_address_template
Most of the operations above take an "address" to operate on. Addresses are
specific to an individual store (e.g bucket name and key for Amazon S3) and
are represented by a simple string, which parse_address should interpret.

Address templates are simply a sprintf style pattern (which only accepts
strings, "%s", and the escape sequence, "%%"). They allow programs using
libzcloud to specicfy simple patterns and still have the store (probably)
be able to list everything matching that pattern. Only permitting strings
in the pattern is only meant to simplify the parsing of the pattern by the store;
programs using libzcloud might only substitute, say, a number.

Besides the store, implementations of libzcloud should also provide an
implementation of addresses. Special handling of address templates is not required,
but might prove useful (e.g. keeping track of there the different parts
of the address begin and end).

Independent of particular stores are the download consumer, upload producer,
progress listener, and list consumer. They are the concern of programs using libzcloud.

libzcloud will eventually include some implementations of its abstractions.
An implementation of an Amazon S3 store is expected along with consumers
(and producers) that write to (and read from) memory buffers and files.

== Plugins ==

Plugins are contained in shared objects (modules) which are found in plugin
directories.  The default plugin directory is $libdir/zcloud-plugins, but this
can be overridden and compile time (--with-zcplugindir) and at runtime
($ZCPLUGINPATH).

Each plugin defines one prefix that can appear in store names, e.g., "s3".
There can be more than one plugin per module.

Each module is accompanied by an XML file describing the plugins it contains.
The name of the XML file is not critical, but should match the name of the
shared object without the "lib" prefix.  For example, libs3.so is paired with
s3.xml.  The XML file has the following structure:

<zcloud-module basename="mycloud">
  <store-plugin prefix="mycl">
  </store-plugin>
</zcloud-module>

The 'basename' given in the cloud-module tag is used to find the shared object,
and should name the object without any suffixes or prefixes.  The shared object
is assumed to reside in the same directory as the XML file.

This file will be expanded significantly to include machine-parsable
information on the specific characteristics of the plugin and other useful
information.

Note that, at present, the XML is parsed with the GLib "Simple XML Parser",
which does not handle non-UTF8 encodings, user entities, or processing
instructions.

== Visibility and Headers ==

There are three kinds of code: plugin, internal, and user code.  Plugins and
user code should have
  #include "zcloud.h"
while internal code should have
  #include "internal.h"
which includes all of the public headers, as well as config.h and a number of
common system headers (but not stdio.h).

Individual internal headers are under lib/internal, while individual public
headers (for use by user code and plugins) are under lib/zcloud.

Symbols defined in internal headers should be flagged with G_GNUC_INTERNAL,
which (with compatible compilers) hides the symbols from visibility outside of
libzcloud.la.  This forms a kind of library-wide 'static' declaration: any
internal functions can be called from anywhere inside libzcloud.la, but cannot
be called by users or plugins.
